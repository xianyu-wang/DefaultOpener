import Foundation
import Combine

struct DutiConfigEntry: Identifiable {
    let id = UUID()
    var bundleId: String
    var type: String // UTI or Extension
    var role: String
}

class ConfigManager: ObservableObject {
    @Published var entries: [DutiConfigEntry] = []
    
    func load(from url: URL) {
        do {
            let content = try String(contentsOf: url, encoding: .utf8)
            self.entries = parse(content: content)
        } catch {
            print("Failed to load config: \(error)")
        }
    }
    
    func save(to url: URL, entries: [DutiConfigEntry]) {
        let content = serialize(entries: entries)
        do {
            try content.write(to: url, atomically: true, encoding: .utf8)
        } catch {
            print("Failed to save config: \(error)")
        }
    }
    
    private func parse(content: String) -> [DutiConfigEntry] {
        var results: [DutiConfigEntry] = []
        let lines = content.components(separatedBy: .newlines)
        
        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
            if trimmed.isEmpty || trimmed.hasPrefix("#") { continue }
            
            // Expected format: Check for lines that don't match standard
            // duti often allows comments relative to standard shell logic
            
            let parts = trimmed.components(separatedBy: .whitespaces).filter { !$0.isEmpty }
            if parts.count >= 2 {
                let bundleId = parts[0]
                let type = parts[1]
                let role = parts.count > 2 ? parts[2] : "all"
                results.append(DutiConfigEntry(bundleId: bundleId, type: type, role: role))
            }
        }
        
        return results
    }
    
    private func serialize(entries: [DutiConfigEntry]) -> String {
        var output = "# Generated by DefaultOpener\n"
        for entry in entries {
            output += "\(entry.bundleId) \(entry.type) \(entry.role)\n"
        }
        return output
    }
}
